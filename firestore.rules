rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * FIRESTORE SECURITY RULES DOCUMENTATION
     * 
     * Core Philosophy: 
     * This ruleset enforces a strict User-Ownership model. Access is primarily determined by 
     * the hierarchical path structure, ensuring that users can only access data nested within 
     * their own unique user ID.
     * 
     * Data Structure: 
     * All application data is organized under the root path `/users/{userId}/`. This includes:
     * - pdfTemplates: Metadata for uploaded PDFs.
     * - formFields: Definitions for interactive fields on a template (sub-collection of pdfTemplates).
     * - filledForms: Specific instances of templates filled with data.
     * - fieldValues: The actual data entered into form fields (sub-collection of filledForms).
     * 
     * Key Security Decisions:
     * 1. Authorization Independence: By using a hierarchical path (`/users/{userId}/...`), 
     *    the ownership of every document is immediately known via the `{userId}` wildcard. 
     *    This avoids expensive `get()` calls and ensures rules are performant.
     * 2. Relational Integrity: On document creation, the rules verify that internal fields 
     *    (like `userId`) match the authenticated user's ID and the path.
     * 3. Immutability: Critical ownership fields are protected from modification during updates.
     * 4. Prototyping Flexibility: While authorization is strictly enforced (who can access what), 
     *    the specific data types of content fields are not validated to allow for rapid UI iteration.
     */

    // --- Global Helper Functions ---

    /** @description Checks if the request is from an authenticated user. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** @description Checks if the authenticated user's UID matches the provided userId. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** @description Checks if the user is the owner and the document exists (for updates/deletes). */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // --- Collection Rules ---

    /**
     * @description Rules for PDF Templates. Ensures users only manage their own templates.
     * @path /users/{userId}/pdfTemplates/{pdfTemplateId}
     * @allow (create) User 'abc' creates a template at /users/abc/pdfTemplates/123 with userId: 'abc'.
     * @deny (list) User 'abc' attempts to list templates at /users/xyz/pdfTemplates.
     * @principle Enforces strict ownership and path-to-data consistency.
     */
    match /users/{userId}/pdfTemplates/{pdfTemplateId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Rules for Form Fields. Inherits ownership from the parent template via path.
       * @path /users/{userId}/pdfTemplates/{pdfTemplateId}/formFields/{formFieldId}
       * @allow (get) User 'abc' reads a field definition for one of their own templates.
       * @deny (update) User 'abc' tries to update a field belonging to User 'xyz'.
       * @principle Path-based authorization for nested resources.
       */
      match /formFields/{formFieldId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.pdfTemplateId == pdfTemplateId;
        allow update: if isExistingOwner(userId) && request.resource.data.pdfTemplateId == resource.data.pdfTemplateId;
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Rules for Filled Forms. Represents a specific user's interaction with a template.
     * @path /users/{userId}/filledForms/{filledFormId}
     * @allow (update) User 'abc' updates the title of their filled form 'form_1'.
     * @deny (create) User 'abc' tries to create a filled form for user 'xyz'.
     * @principle Ownership verification for both read and write operations.
     */
    match /users/{userId}/filledForms/{filledFormId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Rules for Field Values. Stores data for fields within a specific filled form.
       * @path /users/{userId}/filledForms/{filledFormId}/fieldValues/{fieldValueId}
       * @allow (list) User 'abc' retrieves all values for their filled form 'form_1'.
       * @deny (delete) User 'abc' tries to delete values inside User 'xyz's form.
       * @principle Recursive ownership enforcement via hierarchical pathing.
       */
      match /fieldValues/{fieldValueId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.filledFormId == filledFormId;
        allow update: if isExistingOwner(userId) && request.resource.data.filledFormId == resource.data.filledFormId;
        allow delete: if isExistingOwner(userId);
      }
    }

    // --- Catch-all / Default Deny ---
    match /{path=**} {
      allow read, write: if false;
    }
  }
}